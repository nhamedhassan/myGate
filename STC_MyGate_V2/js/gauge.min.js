(function() {
    var AnimatedText;
    var Window;
    var c;
    var BaseDonut;
    var BaseGauge;
    var Donut;
    var Gauge;
    var GaugePointer;
    var TextRenderer;
    var ValueUpdater;
    var addCommas;
    var cutHex;
    var formatNumber;
    var mergeObjects;
    var secondsToString;
    var extend;
    /** @type {function (this:Object, *): boolean} */
    var __hasProp = {}.hasOwnProperty;
    /**
     * @param {Function} child
     * @param {Object} parent
     * @return {?}
     */
    var __extends = function(child, parent) {
        /**
         * @return {undefined}
         */
        function ctor() {
            /** @type {Function} */
            this.constructor = child;
        }
        var key;
        for (key in parent) {
            if (__hasProp.call(parent, key)) {
                child[key] = parent[key];
            }
        }
        return ctor.prototype = parent.prototype, child.prototype = new ctor, child.__super__ = parent.prototype, child;
    };
    !function() {
        var browserRequestAnimationFrame;
        var done;
        var _i;
        var counter;
        var _len;
        var vendor;
        var vendors;
        /** @type {Array} */
        vendors = ["ms", "moz", "webkit", "o"];
        /** @type {number} */
        _i = 0;
        /** @type {number} */
        _len = vendors.length;
        for (;_len > _i && (vendor = vendors[_i], !window.requestAnimationFrame);_i++) {
            window.requestAnimationFrame = window[vendor + "RequestAnimationFrame"];
            window.cancelAnimationFrame = window[vendor + "CancelAnimationFrame"] || window[vendor + "CancelRequestAnimationFrame"];
        }
        return browserRequestAnimationFrame = null, counter = 0, done = {}, requestAnimationFrame ? window.cancelAnimationFrame ? void 0 : (browserRequestAnimationFrame = window.requestAnimationFrame, window.requestAnimationFrame = function(callback, element) {
            var id;
            return id = ++counter, browserRequestAnimationFrame(function() {
                return done[id] ? void 0 : callback();
            }, element), id;
        }, window.cancelAnimationFrame = function(id) {
            return done[id] = true;
        }) : (window.requestAnimationFrame = function(callback, element) {
            var currTime;
            var cgsgGlobalRenderingTimer;
            var lastTime;
            var timeToCall;
            return currTime = (new Date).getTime(), timeToCall = Math.max(0, 16 - (currTime - lastTime)), cgsgGlobalRenderingTimer = window.setTimeout(function() {
                return callback(currTime + timeToCall);
            }, timeToCall), lastTime = currTime + timeToCall, cgsgGlobalRenderingTimer;
        }, window.cancelAnimationFrame = function(id) {
            return clearTimeout(id);
        });
    }();
    /**
     * @return {?}
     */
    String.prototype.hashCode = function() {
        var c;
        var hash;
        var j;
        var max;
        var len;
        if (hash = 0, 0 === this.length) {
            return hash;
        }
        /** @type {number} */
        j = max = 0;
        /** @type {number} */
        len = this.length;
        for (;len >= 0 ? len > max : max > len;j = len >= 0 ? ++max : --max) {
            /** @type {number} */
            c = this.charCodeAt(j);
            /** @type {number} */
            hash = (hash << 5) - hash + c;
            hash &= hash;
        }
        return hash;
    };
    /**
     * @param {string} sec
     * @return {?}
     */
    secondsToString = function(sec) {
        var a;
        var b;
        /** @type {number} */
        a = Math.floor(sec / 3600);
        /** @type {number} */
        b = Math.floor((sec - 3600 * a) / 60);
        sec -= 3600 * a + 60 * b;
        sec += "";
        b += "";
        for (;b.length < 2;) {
            /** @type {string} */
            b = "0" + b;
        }
        for (;sec.length < 2;) {
            /** @type {string} */
            sec = "0" + sec;
        }
        return a = a ? a + ":" : "", a + b + ":" + sec;
    };
    /**
     * @param {?} len
     * @return {?}
     */
    formatNumber = function(len) {
        return addCommas(len.toFixed(0));
    };
    /**
     * @param {Object} object
     * @param {Object} properties
     * @return {?}
     */
    extend = function(object, properties) {
        var key;
        var val;
        for (key in properties) {
            if (__hasProp.call(properties, key)) {
                val = properties[key];
                object[key] = val;
            }
        }
        return object;
    };
    /**
     * @param {Object} opts
     * @param {Object} obj2
     * @return {?}
     */
    mergeObjects = function(opts, obj2) {
        var key;
        var flags;
        var value;
        flags = {};
        for (key in opts) {
            if (__hasProp.call(opts, key)) {
                value = opts[key];
                flags[key] = value;
            }
        }
        for (key in obj2) {
            if (__hasProp.call(obj2, key)) {
                value = obj2[key];
                flags[key] = value;
            }
        }
        return flags;
    };
    /**
     * @param {string} nStr
     * @return {?}
     */
    addCommas = function(nStr) {
        var cx;
        var lorem;
        var text;
        var mode;
        nStr += "";
        /** @type {Array.<string>} */
        lorem = nStr.split(".");
        /** @type {string} */
        text = lorem[0];
        /** @type {string} */
        mode = "";
        if (lorem.length > 1) {
            /** @type {string} */
            mode = "." + lorem[1];
        }
        /** @type {RegExp} */
        cx = /(\d+)(\d{3})/;
        for (;cx.test(text);) {
            /** @type {string} */
            text = text.replace(cx, "$1,$2");
        }
        return text + mode;
    };
    /**
     * @param {string} str
     * @return {?}
     */
    cutHex = function(str) {
        return "#" === str.charAt(0) ? str.substring(1, 7) : str;
    };
    ValueUpdater = function() {
        /**
         * @param {boolean} addToAnimationQueue
         * @param {Object} clear
         * @return {undefined}
         */
        function ValueUpdater(addToAnimationQueue, clear) {
            if (null == addToAnimationQueue) {
                /** @type {boolean} */
                addToAnimationQueue = true;
            }
            this.clear = null != clear ? clear : true;
            if (addToAnimationQueue) {
                AnimationUpdater.add(this);
            }
        }
        return ValueUpdater.prototype.animationSpeed = 32, ValueUpdater.prototype.update = function(force) {
            var diff;
            return null == force && (force = false), force || this.displayedValue !== this.value ? (this.ctx && (this.clear && this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)), diff = this.value - this.displayedValue, Math.abs(diff / this.animationSpeed) <= 0.001 ? this.displayedValue = this.value : this.displayedValue = this.displayedValue + diff / this.animationSpeed, this.render(), true) : false;
        }, ValueUpdater;
    }();
    BaseGauge = function(_super) {
        /**
         * @return {?}
         */
        function BaseGauge() {
            return BaseGauge.__super__.constructor.apply(this, arguments);
        }
        return __extends(BaseGauge, _super), BaseGauge.prototype.displayScale = 1, BaseGauge.prototype.setTextField = function(textField) {
            return this.textField = textField instanceof TextRenderer ? textField : new TextRenderer(textField);
        }, BaseGauge.prototype.setMinValue = function(minValue, silent) {
            var gauge;
            var _i;
            var _len;
            var _ref;
            var _results;
            if (this.minValue = minValue, null == silent && (silent = true), silent) {
                this.displayedValue = this.minValue;
                _ref = this.gp || [];
                /** @type {Array} */
                _results = [];
                /** @type {number} */
                _i = 0;
                _len = _ref.length;
                for (;_len > _i;_i++) {
                    gauge = _ref[_i];
                    _results.push(gauge.displayedValue = this.minValue);
                }
                return _results;
            }
        }, BaseGauge.prototype.setOptions = function(options) {
            return null == options && (options = null), this.options = mergeObjects(this.options, options), this.textField && (this.textField.el.style.fontSize = options.fontSize + "px"), this.options.angle > 0.5 && (this.gauge.options.angle = 0.5), this.configDisplayScale(), this;
        }, BaseGauge.prototype.configDisplayScale = function() {
            var b;
            var a;
            var height;
            var displayScale;
            var width;
            return displayScale = this.displayScale, this.options.highDpiSupport === false ? delete this.displayScale : (a = window.devicePixelRatio || 1, b = this.ctx.webkitBackingStorePixelRatio || (this.ctx.mozBackingStorePixelRatio || (this.ctx.msBackingStorePixelRatio || (this.ctx.oBackingStorePixelRatio || (this.ctx.backingStorePixelRatio || 1)))), this.displayScale = a / b), this.displayScale !== displayScale && (width = this.canvas.G__width || this.canvas.width, height = this.canvas.G__height ||
                this.canvas.height, this.canvas.width = width * this.displayScale, this.canvas.height = height * this.displayScale, this.canvas.style.width = width + "px", this.canvas.style.height = height + "px", this.canvas.G__width = width, this.canvas.G__height = height), this;
        }, BaseGauge;
    }(ValueUpdater);
    TextRenderer = function() {
        /**
         * @param {Node} el
         * @return {undefined}
         */
        function TextRenderer(el) {
            /** @type {Node} */
            this.el = el;
        }
        return TextRenderer.prototype.render = function(gauge) {
            return this.el.innerHTML = formatNumber(gauge.displayedValue);
        }, TextRenderer;
    }();
    AnimatedText = function(_super) {
        /**
         * @param {string} elem
         * @param {string} text
         * @return {undefined}
         */
        function AnimatedText(elem, text) {
            /** @type {string} */
            this.elem = elem;
            this.text = null != text ? text : false;
            /** @type {number} */
            this.value = 1 * this.elem.innerHTML;
            if (this.text) {
                /** @type {number} */
                this.value = 0;
            }
        }
        return __extends(AnimatedText, _super), AnimatedText.prototype.displayedValue = 0, AnimatedText.prototype.value = 0, AnimatedText.prototype.setVal = function(value) {
            return this.value = 1 * value;
        }, AnimatedText.prototype.render = function() {
            var text;
            return text = this.text ? secondsToString(this.displayedValue.toFixed(0)) : addCommas(formatNumber(this.displayedValue)), this.elem.innerHTML = text;
        }, AnimatedText;
    }(ValueUpdater);
    Window = {
        /**
         * @param {Array} nodes
         * @return {?}
         */
        create : function(nodes) {
            var elem;
            var i;
            var len;
            var out;
            /** @type {Array} */
            out = [];
            /** @type {number} */
            i = 0;
            len = nodes.length;
            for (;len > i;i++) {
                elem = nodes[i];
                out.push(new AnimatedText(elem));
            }
            return out;
        }
    };
    GaugePointer = function(_super) {
        /**
         * @param {Object} gauge
         * @return {undefined}
         */
        function GaugePointer(gauge) {
            /** @type {Object} */
            this.gauge = gauge;
            this.ctx = this.gauge.ctx;
            this.canvas = this.gauge.canvas;
            GaugePointer.__super__.constructor.call(this, false, false);
            this.setOptions();
        }
        return __extends(GaugePointer, _super), GaugePointer.prototype.displayedValue = 0, GaugePointer.prototype.value = 0, GaugePointer.prototype.options = {
            strokeWidth : 0.035,
            length : 0.1,
            color : "#000000"
        }, GaugePointer.prototype.setOptions = function(o) {
            return null == o && (o = null), extend(this.options, o), this.length = this.canvas.height * this.options.length, this.strokeWidth = this.canvas.height * this.options.strokeWidth, this.maxValue = this.gauge.maxValue, this.minValue = this.gauge.minValue, this.displayedValue = this.gauge.minValue, this.animationSpeed = this.gauge.animationSpeed, this.options.angle = this.gauge.options.angle;
        }, GaugePointer.prototype.render = function() {
            var angle;
            var centerX;
            var centerY;
            var altIndicatorWidth;
            var y;
            var startX;
            var startY;
            var to_x;
            var to_y;
            return angle = this.gauge.getAngle.call(this, this.displayedValue), centerX = this.canvas.width / 2, centerY = 0.9 * this.canvas.height, to_x = Math.round(centerX + this.length * Math.cos(angle)), to_y = Math.round(centerY + this.length * Math.sin(angle)), startX = Math.round(centerX + this.strokeWidth * Math.cos(angle - Math.PI / 2)), startY = Math.round(centerY + this.strokeWidth * Math.sin(angle - Math.PI / 2)), altIndicatorWidth = Math.round(centerX + this.strokeWidth * Math.cos(angle +
                    Math.PI / 2)), y = Math.round(centerY + this.strokeWidth * Math.sin(angle + Math.PI / 2)), this.ctx.fillStyle = this.options.color, this.ctx.beginPath(), this.ctx.arc(centerX, centerY, this.strokeWidth, 0, 2 * Math.PI, true), this.ctx.fill(), this.ctx.beginPath(), this.ctx.moveTo(startX, startY), this.ctx.lineTo(to_x, to_y), this.ctx.lineTo(altIndicatorWidth, y), this.ctx.fill();
        }, GaugePointer;
    }(ValueUpdater);
    c = function() {
        /**
         * @param {string} elem
         * @return {undefined}
         */
        function Bar(elem) {
            /** @type {string} */
            this.elem = elem;
        }
        return Bar.prototype.updateValues = function(arrValues) {
            return this.value = arrValues[0], this.maxValue = arrValues[1], this.avgValue = arrValues[2], this.render();
        }, Bar.prototype.render = function() {
            var percent;
            var sf_width;
            return this.textField && this.textField.text(formatNumber(this.value)), 0 === this.maxValue && (this.maxValue = 2 * this.avgValue), sf_width = this.value / this.maxValue * 100, percent = this.avgValue / this.maxValue * 100, $(".bar-value", this.elem).css({
                width : sf_width + "%"
            }), $(".typical-value", this.elem).css({
                width : percent + "%"
            });
        }, Bar;
    }();
    Gauge = function(_super) {
        /**
         * @param {HTMLCanvasElement} canvas
         * @return {undefined}
         */
        function Gauge(canvas) {
            /** @type {HTMLCanvasElement} */
            this.canvas = canvas;
            Gauge.__super__.constructor.call(this);
            /** @type {null} */
            this.percentColors = null;
            if ("undefined" != typeof G_vmlCanvasManager) {
                this.canvas = window.G_vmlCanvasManager.initElement(this.canvas);
            }
            this.ctx = this.canvas.getContext("2d");
            /** @type {Array} */
            this.gp = [new GaugePointer(this)];
            this.setOptions();
            this.render();
        }
        return __extends(Gauge, _super), Gauge.prototype.elem = null, Gauge.prototype.value = [20], Gauge.prototype.maxValue = 80, Gauge.prototype.minValue = 0, Gauge.prototype.displayedAngle = 0, Gauge.prototype.displayedValue = 0, Gauge.prototype.lineWidth = 40, Gauge.prototype.paddingBottom = 0.1, Gauge.prototype.percentColors = null, Gauge.prototype.options = {
            colorStart : "#6fadcf",
            colorStop : void 0,
            gradientType : 0,
            strokeColor : "#e0e0e0",
            pointer : {
                length : 0.8,
                strokeWidth : 0.035
            },
            angle : 0.15,
            lineWidth : 0.44,
            fontSize : 40,
            limitMax : false
        }, Gauge.prototype.setOptions = function(options) {
            var gauge;
            var _i;
            var _len;
            var _ref;
            if (null == options) {
                /** @type {null} */
                options = null;
            }
            Gauge.__super__.setOptions.call(this, options);
            this.configPercentColors();
            /** @type {number} */
            this.lineWidth = this.canvas.height * (1 - this.paddingBottom) * this.options.lineWidth;
            /** @type {number} */
            this.radius = this.canvas.height * (1 - this.paddingBottom) - this.lineWidth;
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this.render();
            _ref = this.gp;
            /** @type {number} */
            _i = 0;
            _len = _ref.length;
            for (;_len > _i;_i++) {
                gauge = _ref[_i];
                gauge.setOptions(this.options.pointer);
                gauge.render();
            }
            return this;
        }, Gauge.prototype.configPercentColors = function() {
            var blue;
            var green;
            var i;
            var x;
            var y;
            var _results;
            var red;
            if (this.percentColors = null, void 0 !== this.options.percentColors) {
                /** @type {Array} */
                this.percentColors = new Array;
                /** @type {Array} */
                _results = [];
                /** @type {number} */
                i = x = 0;
                /** @type {number} */
                y = this.options.percentColors.length - 1;
                for (;y >= 0 ? y >= x : x >= y;i = y >= 0 ? ++x : --x) {
                    /** @type {number} */
                    red = parseInt(cutHex(this.options.percentColors[i][1]).substring(0, 2), 16);
                    /** @type {number} */
                    green = parseInt(cutHex(this.options.percentColors[i][1]).substring(2, 4), 16);
                    /** @type {number} */
                    blue = parseInt(cutHex(this.options.percentColors[i][1]).substring(4, 6), 16);
                    _results.push(this.percentColors[i] = {
                        pct : this.options.percentColors[i][0],
                        color : {
                            r : red,
                            g : green,
                            b : blue
                        }
                    });
                }
                return _results;
            }
        }, Gauge.prototype.set = function(value) {
            var i;
            var len;
            var key;
            var ln;
            var e;
            var max;
            var val;
            if (this.displayedValue = this.minValue, value instanceof Array || (value = [value]), value.length > this.gp.length) {
                /** @type {number} */
                i = len = 0;
                /** @type {number} */
                max = value.length - this.gp.length;
                for (;max >= 0 ? max > len : len > max;i = max >= 0 ? ++len : --len) {
                    this.gp.push(new GaugePointer(this));
                }
            }
            /** @type {number} */
            i = 0;
            /** @type {boolean} */
            e = false;
            /** @type {number} */
            key = 0;
            ln = value.length;
            for (;ln > key;key++) {
                val = value[key];
                if (val > this.maxValue) {
                    /** @type {number} */
                    this.maxValue = 1.1 * this.value;
                    /** @type {boolean} */
                    e = true;
                }
                this.gp[i].value = val;
                this.gp[i++].setOptions({
                    maxValue : this.maxValue,
                    angle : this.options.angle
                });
            }
            return this.value = value[value.length - 1], e && this.options.limitMax ? void 0 : AnimationUpdater.run();
        }, Gauge.prototype.getAngle = function(value) {
            return(1 + this.options.angle) * Math.PI + (value - this.minValue) / (this.maxValue - this.minValue) * (1 - 2 * this.options.angle) * Math.PI;
        }, Gauge.prototype.getColorForPercentage = function(pct, deepDataAndEvents) {
            var color;
            var endColor;
            var i;
            var x;
            var rangePct;
            var y;
            var startColor;
            if (0 === pct) {
                color = this.percentColors[0].color;
            } else {
                color = this.percentColors[this.percentColors.length - 1].color;
                /** @type {number} */
                i = x = 0;
                /** @type {number} */
                y = this.percentColors.length - 1;
                for (;y >= 0 ? y >= x : x >= y;i = y >= 0 ? ++x : --x) {
                    if (pct <= this.percentColors[i].pct) {
                        if (deepDataAndEvents === true) {
                            startColor = this.percentColors[i - 1];
                            endColor = this.percentColors[i];
                            /** @type {number} */
                            rangePct = (pct - startColor.pct) / (endColor.pct - startColor.pct);
                            color = {
                                r : Math.floor(startColor.color.r * (1 - rangePct) + endColor.color.r * rangePct),
                                g : Math.floor(startColor.color.g * (1 - rangePct) + endColor.color.g * rangePct),
                                b : Math.floor(startColor.color.b * (1 - rangePct) + endColor.color.b * rangePct)
                            };
                        } else {
                            color = this.percentColors[i].color;
                        }
                        break;
                    }
                }
            }
            return "rgb(" + [color.r, color.g, color.b].join(",") + ")";
        }, Gauge.prototype.getColorForValue = function(val, deepDataAndEvents) {
            var pct;
            return pct = (val - this.minValue) / (this.maxValue - this.minValue), this.getColorForPercentage(pct, deepDataAndEvents);
        }, Gauge.prototype.render = function() {
            var displayedAngle;
            var fillStyle;
            var token;
            var y1;
            var _j;
            var _len;
            var _ref;
            var _results;
            var w;
            /** @type {number} */
            w = this.canvas.width / 2;
            /** @type {number} */
            y1 = this.canvas.height * (1 - this.paddingBottom);
            displayedAngle = this.getAngle(this.displayedValue);
            if (this.textField) {
                this.textField.render(this);
            }
            /** @type {string} */
            this.ctx.lineCap = "butt";
            if (void 0 !== this.options.customFillStyle) {
                fillStyle = this.options.customFillStyle(this);
            } else {
                if (null !== this.percentColors) {
                    fillStyle = this.getColorForValue(this.displayedValue, true);
                } else {
                    if (void 0 !== this.options.colorStop) {
                        fillStyle = 0 === this.options.gradientType ? this.ctx.createRadialGradient(w, y1, 9, w, y1, 70) : this.ctx.createLinearGradient(0, 0, w, 0);
                        fillStyle.addColorStop(0, this.options.colorStart);
                        fillStyle.addColorStop(1, this.options.colorStop);
                    } else {
                        fillStyle = this.options.colorStart;
                    }
                }
            }
            this.ctx.strokeStyle = fillStyle;
            this.ctx.beginPath();
            this.ctx.arc(w, y1, this.radius, (1 + this.options.angle) * Math.PI, displayedAngle, false);
            this.ctx.lineWidth = this.lineWidth;
            this.ctx.stroke();
            this.ctx.strokeStyle = this.options.strokeColor;
            this.ctx.beginPath();
            this.ctx.arc(w, y1, this.radius, displayedAngle, (2 - this.options.angle) * Math.PI, false);
            this.ctx.stroke();
            _ref = this.gp;
            /** @type {Array} */
            _results = [];
            /** @type {number} */
            _j = 0;
            _len = _ref.length;
            for (;_len > _j;_j++) {
                token = _ref[_j];
                _results.push(token.update(true));
            }
            return _results;
        }, Gauge;
    }(BaseGauge);
    BaseDonut = function(_super) {
        /**
         * @param {HTMLCanvasElement} canvas
         * @return {undefined}
         */
        function BaseDonut(canvas) {
            /** @type {HTMLCanvasElement} */
            this.canvas = canvas;
            BaseDonut.__super__.constructor.call(this);
            if ("undefined" != typeof G_vmlCanvasManager) {
                this.canvas = window.G_vmlCanvasManager.initElement(this.canvas);
            }
            this.ctx = this.canvas.getContext("2d");
            this.setOptions();
            this.render();
        }
        return __extends(BaseDonut, _super), BaseDonut.prototype.lineWidth = 15, BaseDonut.prototype.displayedValue = 0, BaseDonut.prototype.value = 33, BaseDonut.prototype.maxValue = 80, BaseDonut.prototype.minValue = 0, BaseDonut.prototype.options = {
            lineWidth : 0.1,
            colorStart : "#6f6ea0",
            colorStop : "#c0c0db",
            strokeColor : "#eeeeee",
            shadowColor : "#eeeeee",
            angle : 0.35
        }, BaseDonut.prototype.getAngle = function(value) {
            return(1 - this.options.angle) * Math.PI + (value - this.minValue) / (this.maxValue - this.minValue) * (2 + this.options.angle - (1 - this.options.angle)) * Math.PI;
        }, BaseDonut.prototype.setOptions = function(options) {
            return null == options && (options = null), BaseDonut.__super__.setOptions.call(this, options), this.lineWidth = this.canvas.height * this.options.lineWidth, this.radius = this.canvas.height / 2 - this.lineWidth / 2, this;
        }, BaseDonut.prototype.set = function(value) {
            return this.value = value, this.value > this.maxValue && (this.maxValue = 1.1 * this.value), AnimationUpdater.run();
        }, BaseDonut.prototype.render = function() {
            var displayedAngle;
            var grdFill;
            var h;
            var start;
            var stop;
            var w;
            return displayedAngle = this.getAngle(this.displayedValue), w = this.canvas.width / 2, h = this.canvas.height / 2, this.textField && this.textField.render(this), grdFill = this.ctx.createRadialGradient(w, h, 39, w, h, 70), grdFill.addColorStop(0, this.options.colorStart), grdFill.addColorStop(1, this.options.colorStop), start = this.radius - this.lineWidth / 2, stop = this.radius + this.lineWidth / 2, this.ctx.strokeStyle = this.options.strokeColor, this.ctx.beginPath(), this.ctx.arc(w, h,
                this.radius, (1 - this.options.angle) * Math.PI, (2 + this.options.angle) * Math.PI, false), this.ctx.lineWidth = this.lineWidth, this.ctx.lineCap = "/*round*/", this.ctx.stroke(), this.ctx.strokeStyle = grdFill, this.ctx.beginPath(), this.ctx.arc(w, h, this.radius, (1 - this.options.angle) * Math.PI, displayedAngle, false), this.ctx.stroke();
        }, BaseDonut;
    }(BaseGauge);
    Donut = function(_super) {
        /**
         * @return {?}
         */
        function Donut() {
            return Donut.__super__.constructor.apply(this, arguments);
        }
        return __extends(Donut, _super), Donut.prototype.strokeGradient = function(w, h, start, stop) {
            var grd;
            return grd = this.ctx.createRadialGradient(w, h, start, w, h, stop), grd.addColorStop(0, this.options.shadowColor), grd.addColorStop(0.12, this.options._orgStrokeColor), grd.addColorStop(0.88, this.options._orgStrokeColor), grd.addColorStop(1, this.options.shadowColor), grd;
        }, Donut.prototype.setOptions = function(options) {
            var h;
            var start;
            var stop;
            var w;
            return null == options && (options = null), Donut.__super__.setOptions.call(this, options), w = this.canvas.width / 2, h = this.canvas.height / 2, start = this.radius - this.lineWidth / 2, stop = this.radius + this.lineWidth / 2, this.options._orgStrokeColor = this.options.strokeColor, this.options.strokeColor = this.strokeGradient(w, h, start, stop), this;
        }, Donut;
    }(BaseDonut);
    window.AnimationUpdater = {
        elements : [],
        animId : null,
        /**
         * @param {Array} objs
         * @return {?}
         */
        addAll : function(objs) {
            var paths;
            var id;
            var _len;
            var rulesets;
            /** @type {Array} */
            rulesets = [];
            /** @type {number} */
            id = 0;
            _len = objs.length;
            for (;_len > id;id++) {
                paths = objs[id];
                rulesets.push(AnimationUpdater.elements.push(paths));
            }
            return rulesets;
        },
        /**
         * @param {?} suite
         * @return {?}
         */
        add : function(suite) {
            return AnimationUpdater.elements.push(suite);
        },
        /**
         * @return {?}
         */
        run : function() {
            var a;
            var token;
            var _j;
            var _len;
            var _ref;
            /** @type {boolean} */
            a = true;
            _ref = AnimationUpdater.elements;
            /** @type {number} */
            _j = 0;
            _len = _ref.length;
            for (;_len > _j;_j++) {
                token = _ref[_j];
                if (token.update()) {
                    /** @type {boolean} */
                    a = false;
                }
            }
            return a ? cancelAnimationFrame(AnimationUpdater.animId) : AnimationUpdater.animId = requestAnimationFrame(AnimationUpdater.run);
        }
    };
    if ("function" == typeof window.define && null != window.define.amd) {
        define(function() {
            return{
                Gauge : Gauge,
                Donut : Donut,
                BaseDonut : BaseDonut,
                TextRenderer : TextRenderer
            };
        });
    } else {
        if ("undefined" != typeof module && null != module.exports) {
            module.exports = {
                Gauge : Gauge,
                Donut : Donut,
                BaseDonut : BaseDonut,
                TextRenderer : TextRenderer
            };
        } else {
            window.Gauge = Gauge;
            window.Donut = Donut;
            window.BaseDonut = BaseDonut;
            window.TextRenderer = TextRenderer;
        }
    }
}).call(this);
